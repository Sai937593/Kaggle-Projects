{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "66999561",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:25.070617Z",
     "iopub.status.busy": "2024-10-25T21:07:25.069668Z",
     "iopub.status.idle": "2024-10-25T21:07:25.074169Z",
     "shell.execute_reply": "2024-10-25T21:07:25.073464Z"
    },
    "papermill": {
     "duration": 0.0219,
     "end_time": "2024-10-25T21:07:25.076051",
     "exception": false,
     "start_time": "2024-10-25T21:07:25.054151",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# !pip install --upgrade pip\n",
    "# !pip install ipywidgets jupyter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "0ce8688e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:25.105173Z",
     "iopub.status.busy": "2024-10-25T21:07:25.104872Z",
     "iopub.status.idle": "2024-10-25T21:07:40.546988Z",
     "shell.execute_reply": "2024-10-25T21:07:40.545946Z"
    },
    "papermill": {
     "duration": 15.458029,
     "end_time": "2024-10-25T21:07:40.548982",
     "exception": false,
     "start_time": "2024-10-25T21:07:25.090953",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Connecting to TPU \n",
      "\n",
      "Memory growth enabled for GPUs.\n",
      "Mirrored Strategy initialized with GPUs.\n"
     ]
    }
   ],
   "source": [
    "import tensorflow as tf\n",
    "\n",
    "print('Connecting to TPU \\n')\n",
    "# List GPUs and set memory growth before initializing TensorFlow or Keras models\n",
    "gpus = tf.config.list_physical_devices('GPU')\n",
    "if gpus:\n",
    "    try:\n",
    "        for gpu in gpus:\n",
    "            tf.config.experimental.set_memory_growth(gpu, True)\n",
    "        print(\"Memory growth enabled for GPUs.\")\n",
    "    except RuntimeError as e:\n",
    "        print(f\"Error setting memory growth: {e}\")\n",
    "else:\n",
    "    print(\"No GPUs found.\")\n",
    "if gpus:\n",
    "    strategy = tf.distribute.MirroredStrategy()\n",
    "    print(\"Mirrored Strategy initialized with GPUs.\")\n",
    "else:\n",
    "    strategy = tf.distribute.get_strategy()  # Default strategy if no GPUs available\n",
    "    print(\"Using Default Strategy.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "beec84a9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:40.577505Z",
     "iopub.status.busy": "2024-10-25T21:07:40.576950Z",
     "iopub.status.idle": "2024-10-25T21:07:40.581312Z",
     "shell.execute_reply": "2024-10-25T21:07:40.580466Z"
    },
    "papermill": {
     "duration": 0.020709,
     "end_time": "2024-10-25T21:07:40.583312",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.562603",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# import tensorflow as tf\n",
    "\n",
    "# # List all physical devices, specifically looking for GPUs\n",
    "# gpus = tf.config.list_physical_devices('GPU')\n",
    "# print(f\"GPUs available: {gpus}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f3759ec5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:40.610933Z",
     "iopub.status.busy": "2024-10-25T21:07:40.610661Z",
     "iopub.status.idle": "2024-10-25T21:07:40.614604Z",
     "shell.execute_reply": "2024-10-25T21:07:40.613737Z"
    },
    "id": "AGwgatwy4zqh",
    "papermill": {
     "duration": 0.01975,
     "end_time": "2024-10-25T21:07:40.616509",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.596759",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# import os\n",
    "\n",
    "# # Create the directory explicitly with the absolute path\n",
    "# os.makedirs(\"~/.kaggle\", exist_ok=True)\n",
    "\n",
    "# !cp \"/kaggle/input/kaggle-token/kaggle (1).json\" ~/kaggle.json\n",
    "# # Copy the kaggle.json file from your Google Drive to the required location\n",
    "# !cp ~/kaggle.json ~/.kaggle/\n",
    "\n",
    "# # Set the correct permissions for the Kaggle API token\n",
    "# !chmod 600 ~/.kaggle/kaggle.json\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c0cc912",
   "metadata": {
    "papermill": {
     "duration": 0.012866,
     "end_time": "2024-10-25T21:07:40.642386",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.629520",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e2434d2f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:40.669759Z",
     "iopub.status.busy": "2024-10-25T21:07:40.669482Z",
     "iopub.status.idle": "2024-10-25T21:07:40.673061Z",
     "shell.execute_reply": "2024-10-25T21:07:40.672261Z"
    },
    "id": "lnWQ8Xfp5RWI",
    "outputId": "51ac6c76-76f4-4d42-a310-f2987df37d13",
    "papermill": {
     "duration": 0.019478,
     "end_time": "2024-10-25T21:07:40.675010",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.655532",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# !pip install kaggle\n",
    "# !kaggle competitions download -c playground-series-s4e10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "939591b3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:40.703742Z",
     "iopub.status.busy": "2024-10-25T21:07:40.703451Z",
     "iopub.status.idle": "2024-10-25T21:07:40.707080Z",
     "shell.execute_reply": "2024-10-25T21:07:40.706271Z"
    },
    "id": "SStBLetO6Lzv",
    "papermill": {
     "duration": 0.020816,
     "end_time": "2024-10-25T21:07:40.708906",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.688090",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# from zipfile import ZipFile\n",
    "\n",
    "# with ZipFile('/content/playground-series-s4e10.zip', 'r') as zip_ref:\n",
    "#     zip_ref.extractall('/content')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "0b4a238e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:40.736270Z",
     "iopub.status.busy": "2024-10-25T21:07:40.735975Z",
     "iopub.status.idle": "2024-10-25T21:07:40.970657Z",
     "shell.execute_reply": "2024-10-25T21:07:40.969759Z"
    },
    "id": "4-aOwIrp2pYI",
    "outputId": "e6ef0214-f215-4ace-94ca-27dcaf0ca8f8",
    "papermill": {
     "duration": 0.250737,
     "end_time": "2024-10-25T21:07:40.973023",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.722286",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "reading the csv files into pandas dataframes.\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "\n",
    "print(f'reading the csv files into pandas dataframes.')\n",
    "\n",
    "try:\n",
    "    train_df = pd.read_csv('/kaggle/input/playground-series-s4e10/train.csv')\n",
    "    test_df = pd.read_csv('/kaggle/input/playground-series-s4e10/test.csv')\n",
    "    sub_df = pd.read_csv('/kaggle/input/playground-series-s4e10/sample_submission.csv')\n",
    "except Exception as e:\n",
    "    print(f'could not load the csv files into pandas dataframes')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "46964605",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.001544Z",
     "iopub.status.busy": "2024-10-25T21:07:41.001173Z",
     "iopub.status.idle": "2024-10-25T21:07:41.005072Z",
     "shell.execute_reply": "2024-10-25T21:07:41.004256Z"
    },
    "id": "msVqxn5m2pYI",
    "papermill": {
     "duration": 0.02012,
     "end_time": "2024-10-25T21:07:41.007090",
     "exception": false,
     "start_time": "2024-10-25T21:07:40.986970",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# train_df.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "0d95dbc2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.034307Z",
     "iopub.status.busy": "2024-10-25T21:07:41.034000Z",
     "iopub.status.idle": "2024-10-25T21:07:41.037862Z",
     "shell.execute_reply": "2024-10-25T21:07:41.036967Z"
    },
    "id": "8CVAOYiU2pYJ",
    "papermill": {
     "duration": 0.019532,
     "end_time": "2024-10-25T21:07:41.039668",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.020136",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# test_df.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "c9d72886",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.067248Z",
     "iopub.status.busy": "2024-10-25T21:07:41.066953Z",
     "iopub.status.idle": "2024-10-25T21:07:41.070726Z",
     "shell.execute_reply": "2024-10-25T21:07:41.069886Z"
    },
    "id": "dhU-Nqzs2pYJ",
    "papermill": {
     "duration": 0.019471,
     "end_time": "2024-10-25T21:07:41.072500",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.053029",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# train_df.isnull().any(), test_df.isnull().any()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "21bb3ab5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.099938Z",
     "iopub.status.busy": "2024-10-25T21:07:41.099635Z",
     "iopub.status.idle": "2024-10-25T21:07:41.107936Z",
     "shell.execute_reply": "2024-10-25T21:07:41.106964Z"
    },
    "id": "A4GXB1u62pYJ",
    "papermill": {
     "duration": 0.024168,
     "end_time": "2024-10-25T21:07:41.109967",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.085799",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "cat_cols = train_df.select_dtypes('object').columns\n",
    "num_cols = []\n",
    "for col in train_df.select_dtypes(exclude='object').columns:\n",
    "    if col not in ('id', 'loan_status'):\n",
    "        num_cols.append(col)\n",
    "# num_cols, cat_cols"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "3e0d5274",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.138098Z",
     "iopub.status.busy": "2024-10-25T21:07:41.137802Z",
     "iopub.status.idle": "2024-10-25T21:07:41.141671Z",
     "shell.execute_reply": "2024-10-25T21:07:41.140782Z"
    },
    "id": "8MTuOiD92pYJ",
    "papermill": {
     "duration": 0.020096,
     "end_time": "2024-10-25T21:07:41.143554",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.123458",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# train_df['loan_status'].value_counts(normalize=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "b09cddc9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.172250Z",
     "iopub.status.busy": "2024-10-25T21:07:41.171922Z",
     "iopub.status.idle": "2024-10-25T21:07:41.178989Z",
     "shell.execute_reply": "2024-10-25T21:07:41.178086Z"
    },
    "id": "59Vicvtb2pYJ",
    "papermill": {
     "duration": 0.023747,
     "end_time": "2024-10-25T21:07:41.181087",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.157340",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "def box_plots_num_cols(df, columns):\n",
    "    df = df.copy()\n",
    "    base_width = 10\n",
    "    base_height = 5\n",
    "    rows = len(columns)\n",
    "    cols = 1\n",
    "    fig_width = cols * base_width\n",
    "    fig_height = rows * base_height\n",
    "    fig, axes = plt.subplots(rows, cols, figsize=(fig_width, fig_height))\n",
    "    axes = axes.flatten() if rows > 1 else [axes]\n",
    "    for i, col in enumerate(columns):\n",
    "        axes[i].boxplot(df[col])\n",
    "        axes[i].set_title(col)\n",
    "    for j in range(i+1, len(axes)):\n",
    "        axes[j].axis('off')\n",
    "    plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "b7dbe948",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.209907Z",
     "iopub.status.busy": "2024-10-25T21:07:41.209619Z",
     "iopub.status.idle": "2024-10-25T21:07:41.213587Z",
     "shell.execute_reply": "2024-10-25T21:07:41.212662Z"
    },
    "id": "5q3wrA282pYK",
    "papermill": {
     "duration": 0.020504,
     "end_time": "2024-10-25T21:07:41.215491",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.194987",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# box_plots_num_cols(train_df, num_cols)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "ffbaacfa",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:41.244104Z",
     "iopub.status.busy": "2024-10-25T21:07:41.243836Z",
     "iopub.status.idle": "2024-10-25T21:07:42.016105Z",
     "shell.execute_reply": "2024-10-25T21:07:42.015343Z"
    },
    "id": "ZtOn9zxs2pYK",
    "papermill": {
     "duration": 0.789176,
     "end_time": "2024-10-25T21:07:42.018416",
     "exception": false,
     "start_time": "2024-10-25T21:07:41.229240",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from scipy import stats\n",
    "import numpy as np\n",
    "\n",
    "def remove_outliers(df:pd.DataFrame(), cols, beta):\n",
    "    df = df.copy()\n",
    "    for col in cols:\n",
    "#         print(f'removing {col} outliers:\\n')\n",
    "        data = df[col]\n",
    "        iqr = stats.iqr(data)\n",
    "        q1 = np.percentile(data, 25)\n",
    "        q3 = np.percentile(data, 75)\n",
    "        outlier_low = q1 - beta * iqr\n",
    "        outlier_high = q1 + beta * iqr\n",
    "#         print(f'outlier_low:{outlier_low}, outlier_high: {outlier_high}')\n",
    "        df = df[(data >= outlier_low) & (data <= outlier_high)]\n",
    "    return df\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "d6ae482d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.047193Z",
     "iopub.status.busy": "2024-10-25T21:07:42.046712Z",
     "iopub.status.idle": "2024-10-25T21:07:42.119496Z",
     "shell.execute_reply": "2024-10-25T21:07:42.118532Z"
    },
    "id": "CbzNHkWx2pYK",
    "outputId": "d4f41e9f-20c6-45a8-d9a6-3b153ddb7ad9",
    "papermill": {
     "duration": 0.089405,
     "end_time": "2024-10-25T21:07:42.121818",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.032413",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "removing outliers before oversampling\n",
      "removed outliers\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "((24802, 13), (58645, 13))"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(f'removing outliers before oversampling')\n",
    "df_clean = remove_outliers(train_df, num_cols, 1.5)\n",
    "# box_plots_num_cols(df_clean, num_cols)\n",
    "print('removed outliers')\n",
    "df_clean.shape, train_df.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "6905d656",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.150497Z",
     "iopub.status.busy": "2024-10-25T21:07:42.150141Z",
     "iopub.status.idle": "2024-10-25T21:07:42.156058Z",
     "shell.execute_reply": "2024-10-25T21:07:42.155339Z"
    },
    "id": "fkP1sW402pYK",
    "papermill": {
     "duration": 0.02241,
     "end_time": "2024-10-25T21:07:42.157938",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.135528",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def hist_plot_cat_cols(df:pd.DataFrame(), cat_cols=cat_cols):\n",
    "    df = df.copy()\n",
    "    fig, axes_cat = plt.subplots(1, len(cat_cols), figsize=(20, 10))\n",
    "    for i, col in enumerate(cat_cols):\n",
    "        axes_cat[i].hist(df[col])\n",
    "        axes_cat[i].set_title(col)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "39de9b5a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.185816Z",
     "iopub.status.busy": "2024-10-25T21:07:42.185531Z",
     "iopub.status.idle": "2024-10-25T21:07:42.189158Z",
     "shell.execute_reply": "2024-10-25T21:07:42.188460Z"
    },
    "id": "XWZIcwpD2pYK",
    "papermill": {
     "duration": 0.01963,
     "end_time": "2024-10-25T21:07:42.190959",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.171329",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# hist_plot_cat_cols(train_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "2b870760",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.218816Z",
     "iopub.status.busy": "2024-10-25T21:07:42.218540Z",
     "iopub.status.idle": "2024-10-25T21:07:42.222146Z",
     "shell.execute_reply": "2024-10-25T21:07:42.221316Z"
    },
    "id": "6Daiqx6X2pYL",
    "papermill": {
     "duration": 0.01962,
     "end_time": "2024-10-25T21:07:42.224088",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.204468",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# hist_plot_cat_cols(df_clean)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "067f0508",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.251722Z",
     "iopub.status.busy": "2024-10-25T21:07:42.251411Z",
     "iopub.status.idle": "2024-10-25T21:07:42.485430Z",
     "shell.execute_reply": "2024-10-25T21:07:42.484032Z"
    },
    "id": "iz0XxUy12pYL",
    "outputId": "a04b5901-3a48-4ba2-d72e-b9cef5e045fe",
    "papermill": {
     "duration": 0.250031,
     "end_time": "2024-10-25T21:07:42.487537",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.237506",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "encoding the categorical features\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 24802 entries, 0 to 24801\n",
      "Data columns (total 21 columns):\n",
      " #   Column                          Non-Null Count  Dtype  \n",
      "---  ------                          --------------  -----  \n",
      " 0   loan_grade                      24802 non-null  float64\n",
      " 1   person_home_ownership_MORTGAGE  24802 non-null  float64\n",
      " 2   person_home_ownership_OTHER     24802 non-null  float64\n",
      " 3   person_home_ownership_OWN       24802 non-null  float64\n",
      " 4   person_home_ownership_RENT      24802 non-null  float64\n",
      " 5   loan_intent_DEBTCONSOLIDATION   24802 non-null  float64\n",
      " 6   loan_intent_EDUCATION           24802 non-null  float64\n",
      " 7   loan_intent_HOMEIMPROVEMENT     24802 non-null  float64\n",
      " 8   loan_intent_MEDICAL             24802 non-null  float64\n",
      " 9   loan_intent_PERSONAL            24802 non-null  float64\n",
      " 10  loan_intent_VENTURE             24802 non-null  float64\n",
      " 11  cb_person_default_on_file_N     24802 non-null  float64\n",
      " 12  cb_person_default_on_file_Y     24802 non-null  float64\n",
      " 13  person_age                      24802 non-null  float64\n",
      " 14  person_income                   24802 non-null  float64\n",
      " 15  person_emp_length               24802 non-null  float64\n",
      " 16  loan_amnt                       24802 non-null  float64\n",
      " 17  loan_int_rate                   24802 non-null  float64\n",
      " 18  loan_percent_income             24802 non-null  float64\n",
      " 19  cb_person_cred_hist_length      24802 non-null  float64\n",
      " 20  loan_status                     24802 non-null  float64\n",
      "dtypes: float64(21)\n",
      "memory usage: 4.0 MB\n"
     ]
    }
   ],
   "source": [
    "from sklearn.preprocessing import OrdinalEncoder, OneHotEncoder\n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.pipeline import Pipeline\n",
    "\n",
    "print('encoding the categorical features')\n",
    "df_clean = df_clean.drop(columns=['id'])\n",
    "\n",
    "ord_enc = OrdinalEncoder()\n",
    "one_hot_enc = OneHotEncoder(sparse_output=False)\n",
    "\n",
    "ordinal_cols = ['loan_grade']\n",
    "one_hot_cols = [col for col in cat_cols if col != 'loan_grade']\n",
    "remaining_cols = [col for col in df_clean.columns if col not in cat_cols]\n",
    "\n",
    "encoder = ColumnTransformer(\n",
    "            transformers=[\n",
    "                ('ordinal_encoder', ord_enc, ordinal_cols),\n",
    "                ('one_hot_encoder', one_hot_enc, one_hot_cols),\n",
    "                ('passthrough', 'passthrough', remaining_cols )\n",
    "            ]\n",
    ")\n",
    "\n",
    "encoded_data = encoder.fit_transform(df_clean)\n",
    "one_hot_enc.fit(df_clean[one_hot_cols])\n",
    "one_hot_encoded_cols = one_hot_enc.get_feature_names_out(one_hot_cols)\n",
    "all_cols = ordinal_cols + list(one_hot_encoded_cols) + remaining_cols\n",
    "df_encoded = pd.DataFrame(encoded_data, columns=all_cols)\n",
    "df_encoded.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "1c04c8af",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:07:42.516727Z",
     "iopub.status.busy": "2024-10-25T21:07:42.516334Z",
     "iopub.status.idle": "2024-10-25T21:08:00.448262Z",
     "shell.execute_reply": "2024-10-25T21:08:00.447284Z"
    },
    "id": "6bnWn1Nk2pYL",
    "outputId": "19936ed2-b00d-4dd5-8be8-12669aa48076",
    "papermill": {
     "duration": 17.948401,
     "end_time": "2024-10-25T21:08:00.450238",
     "exception": false,
     "start_time": "2024-10-25T21:07:42.501837",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.10/pty.py:89: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n",
      "  pid, fd = os.forkpty()\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collecting imblearn\r\n",
      "  Downloading imblearn-0.0-py2.py3-none-any.whl.metadata (355 bytes)\r\n",
      "Requirement already satisfied: imbalanced-learn in /opt/conda/lib/python3.10/site-packages (from imblearn) (0.12.3)\r\n",
      "Requirement already satisfied: numpy>=1.17.3 in /opt/conda/lib/python3.10/site-packages (from imbalanced-learn->imblearn) (1.26.4)\r\n",
      "Requirement already satisfied: scipy>=1.5.0 in /opt/conda/lib/python3.10/site-packages (from imbalanced-learn->imblearn) (1.14.1)\r\n",
      "Requirement already satisfied: scikit-learn>=1.0.2 in /opt/conda/lib/python3.10/site-packages (from imbalanced-learn->imblearn) (1.2.2)\r\n",
      "Requirement already satisfied: joblib>=1.1.1 in /opt/conda/lib/python3.10/site-packages (from imbalanced-learn->imblearn) (1.4.2)\r\n",
      "Requirement already satisfied: threadpoolctl>=2.0.0 in /opt/conda/lib/python3.10/site-packages (from imbalanced-learn->imblearn) (3.5.0)\r\n",
      "Downloading imblearn-0.0-py2.py3-none-any.whl (1.9 kB)\r\n",
      "Installing collected packages: imblearn\r\n",
      "Successfully installed imblearn-0.0\r\n",
      "oversampling using SVMSMOTE\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "((46192, 20), (46192,), (46192, 20), (46192,))"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "!pip install imblearn\n",
    "from imblearn.over_sampling import SMOTE, SVMSMOTE\n",
    "\n",
    "print(f'oversampling using SVMSMOTE')\n",
    "df_enc_copy = df_encoded.copy()\n",
    "\n",
    "smote = SMOTE(random_state=32,  k_neighbors=10)\n",
    "svm_smote = SVMSMOTE(random_state=32, k_neighbors=10,m_neighbors=10)\n",
    "\n",
    "X = df_enc_copy.drop(columns=['loan_status'])\n",
    "y = df_enc_copy.loc[:, 'loan_status']\n",
    "\n",
    "X_smote, y_smote = smote.fit_resample(X, y)\n",
    "X_svm_smote, y_svm_smote = svm_smote.fit_resample(X, y)\n",
    "X_smote.shape, y_smote.shape, X_svm_smote.shape, y_svm_smote.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b08f6dbe",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:00.480818Z",
     "iopub.status.busy": "2024-10-25T21:08:00.479993Z",
     "iopub.status.idle": "2024-10-25T21:08:00.486123Z",
     "shell.execute_reply": "2024-10-25T21:08:00.485266Z"
    },
    "id": "x65j6BfZ2pYL",
    "papermill": {
     "duration": 0.023395,
     "end_time": "2024-10-25T21:08:00.488063",
     "exception": false,
     "start_time": "2024-10-25T21:08:00.464668",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "smote_df = X_smote\n",
    "smote_df['loan_status'] = y_smote\n",
    "\n",
    "svm_smote_df = X_svm_smote\n",
    "svm_smote_df['loan_status'] = y_svm_smote\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "ca2778b4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:00.517848Z",
     "iopub.status.busy": "2024-10-25T21:08:00.517552Z",
     "iopub.status.idle": "2024-10-25T21:08:00.521187Z",
     "shell.execute_reply": "2024-10-25T21:08:00.520474Z"
    },
    "id": "sU1TZD2M2pYL",
    "papermill": {
     "duration": 0.020608,
     "end_time": "2024-10-25T21:08:00.523130",
     "exception": false,
     "start_time": "2024-10-25T21:08:00.502522",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# c = [col for col in smote_df.columns if col not in one_hot_encoded_cols]\n",
    "# box_plots_num_cols(smote_df, c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "bcd925f7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:00.552350Z",
     "iopub.status.busy": "2024-10-25T21:08:00.552034Z",
     "iopub.status.idle": "2024-10-25T21:08:00.555579Z",
     "shell.execute_reply": "2024-10-25T21:08:00.554766Z"
    },
    "id": "gQQuhfqk2pYL",
    "papermill": {
     "duration": 0.020267,
     "end_time": "2024-10-25T21:08:00.557437",
     "exception": false,
     "start_time": "2024-10-25T21:08:00.537170",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# c2 = [col for col in svm_smote_df.columns if col not in one_hot_encoded_cols]\n",
    "# box_plots_num_cols(svm_smote_df, c2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "44b00321",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:00.587224Z",
     "iopub.status.busy": "2024-10-25T21:08:00.586884Z",
     "iopub.status.idle": "2024-10-25T21:08:00.590608Z",
     "shell.execute_reply": "2024-10-25T21:08:00.589755Z"
    },
    "id": "sQ-xZAX22pYL",
    "papermill": {
     "duration": 0.021004,
     "end_time": "2024-10-25T21:08:00.592614",
     "exception": false,
     "start_time": "2024-10-25T21:08:00.571610",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# smote_corr = smote_df.corr()\n",
    "# svm_smote_corr = svm_smote_df.corr()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "6d9ffc1b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:00.621747Z",
     "iopub.status.busy": "2024-10-25T21:08:00.621483Z",
     "iopub.status.idle": "2024-10-25T21:08:01.044644Z",
     "shell.execute_reply": "2024-10-25T21:08:01.043692Z"
    },
    "id": "0ZCuXkmt2pYL",
    "papermill": {
     "duration": 0.440238,
     "end_time": "2024-10-25T21:08:01.046873",
     "exception": false,
     "start_time": "2024-10-25T21:08:00.606635",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import seaborn as sns\n",
    "\n",
    "def heatmap_corr(corr):\n",
    "    plt.figure(figsize=(10, 8))\n",
    "    sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=\".2f\", linewidths=0.5)\n",
    "    plt.title('Correlation Heatmap')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "60c48325",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.077884Z",
     "iopub.status.busy": "2024-10-25T21:08:01.077086Z",
     "iopub.status.idle": "2024-10-25T21:08:01.081346Z",
     "shell.execute_reply": "2024-10-25T21:08:01.080450Z"
    },
    "id": "8ZJUeWU-2pYL",
    "papermill": {
     "duration": 0.021546,
     "end_time": "2024-10-25T21:08:01.083212",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.061666",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# heatmap_corr(smote_corr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "d068a747",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.112654Z",
     "iopub.status.busy": "2024-10-25T21:08:01.112349Z",
     "iopub.status.idle": "2024-10-25T21:08:01.116091Z",
     "shell.execute_reply": "2024-10-25T21:08:01.115252Z"
    },
    "id": "X8R0Xdsk2pYM",
    "papermill": {
     "duration": 0.020536,
     "end_time": "2024-10-25T21:08:01.118038",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.097502",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# heatmap_corr(svm_smote_corr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "b8a8d481",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.147180Z",
     "iopub.status.busy": "2024-10-25T21:08:01.146882Z",
     "iopub.status.idle": "2024-10-25T21:08:01.150527Z",
     "shell.execute_reply": "2024-10-25T21:08:01.149679Z"
    },
    "id": "rrdxxXsu2pYM",
    "papermill": {
     "duration": 0.020279,
     "end_time": "2024-10-25T21:08:01.152449",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.132170",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# high_smote_corr = smote_corr[(abs(smote_corr) > 0.7) & (abs(smote_corr) != 1.0)]\n",
    "# heatmap_corr(high_smote_corr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "6cab3717",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.181652Z",
     "iopub.status.busy": "2024-10-25T21:08:01.181377Z",
     "iopub.status.idle": "2024-10-25T21:08:01.184899Z",
     "shell.execute_reply": "2024-10-25T21:08:01.184073Z"
    },
    "id": "U0kFKuHp2pYM",
    "papermill": {
     "duration": 0.020304,
     "end_time": "2024-10-25T21:08:01.186714",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.166410",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# high_svm_smote_corr = svm_smote_corr[(abs(svm_smote_corr) > 0.7) & (abs(svm_smote_corr) != 1.0)]\n",
    "# heatmap_corr(high_svm_smote_corr)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "35527106",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.215705Z",
     "iopub.status.busy": "2024-10-25T21:08:01.215401Z",
     "iopub.status.idle": "2024-10-25T21:08:01.232959Z",
     "shell.execute_reply": "2024-10-25T21:08:01.232000Z"
    },
    "id": "QE4NvjnB2pYM",
    "outputId": "4f2a850d-c619-4c0c-fa78-7b8fe3b518ef",
    "papermill": {
     "duration": 0.034452,
     "end_time": "2024-10-25T21:08:01.235109",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.200657",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "dropping the column person home ownership rent\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 46192 entries, 0 to 46191\n",
      "Data columns (total 20 columns):\n",
      " #   Column                          Non-Null Count  Dtype  \n",
      "---  ------                          --------------  -----  \n",
      " 0   loan_grade                      46192 non-null  float64\n",
      " 1   person_home_ownership_MORTGAGE  46192 non-null  float64\n",
      " 2   person_home_ownership_OTHER     46192 non-null  float64\n",
      " 3   person_home_ownership_OWN       46192 non-null  float64\n",
      " 4   loan_intent_DEBTCONSOLIDATION   46192 non-null  float64\n",
      " 5   loan_intent_EDUCATION           46192 non-null  float64\n",
      " 6   loan_intent_HOMEIMPROVEMENT     46192 non-null  float64\n",
      " 7   loan_intent_MEDICAL             46192 non-null  float64\n",
      " 8   loan_intent_PERSONAL            46192 non-null  float64\n",
      " 9   loan_intent_VENTURE             46192 non-null  float64\n",
      " 10  cb_person_default_on_file_N     46192 non-null  float64\n",
      " 11  cb_person_default_on_file_Y     46192 non-null  float64\n",
      " 12  person_age                      46192 non-null  float64\n",
      " 13  person_income                   46192 non-null  float64\n",
      " 14  person_emp_length               46192 non-null  float64\n",
      " 15  loan_amnt                       46192 non-null  float64\n",
      " 16  loan_int_rate                   46192 non-null  float64\n",
      " 17  loan_percent_income             46192 non-null  float64\n",
      " 18  cb_person_cred_hist_length      46192 non-null  float64\n",
      " 19  loan_status                     46192 non-null  float64\n",
      "dtypes: float64(20)\n",
      "memory usage: 7.0 MB\n"
     ]
    }
   ],
   "source": [
    "print('dropping the column person home ownership rent')\n",
    "df_final = svm_smote_df.drop(columns=[ 'person_home_ownership_RENT'])\n",
    "df_final.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "55a80270",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.265490Z",
     "iopub.status.busy": "2024-10-25T21:08:01.264891Z",
     "iopub.status.idle": "2024-10-25T21:08:01.290373Z",
     "shell.execute_reply": "2024-10-25T21:08:01.289536Z"
    },
    "id": "iese6I-52pYM",
    "outputId": "166a9cbb-94cf-4208-b4dc-cf8ca94f6e2b",
    "papermill": {
     "duration": 0.042429,
     "end_time": "2024-10-25T21:08:01.292356",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.249927",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "splitting the dataset into train and test\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "((22321, 20), (2481, 20))"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn.model_selection import StratifiedShuffleSplit\n",
    "\n",
    "print('splitting the dataset into train and test')\n",
    "\n",
    "sss = StratifiedShuffleSplit(n_splits=1, random_state=32, test_size=0.1)\n",
    "for tr, te in sss.split(X, y):\n",
    "    df_train = df_final.iloc[tr]\n",
    "    df_test  = df_final.iloc[te]\n",
    "target_col = 'loan_status'\n",
    "features_cols = [col for col in df_train.columns if col != target_col]\n",
    "df_train.shape, df_test.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "af82a5f9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:01.323990Z",
     "iopub.status.busy": "2024-10-25T21:08:01.323702Z",
     "iopub.status.idle": "2024-10-25T21:08:06.806193Z",
     "shell.execute_reply": "2024-10-25T21:08:06.805398Z"
    },
    "id": "i9y4ryJC2pYM",
    "papermill": {
     "duration": 5.500358,
     "end_time": "2024-10-25T21:08:06.808502",
     "exception": false,
     "start_time": "2024-10-25T21:08:01.308144",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "preparing the datasets for tpu and splitting them into train and valid datasets: \n",
      "\n"
     ]
    }
   ],
   "source": [
    "import tensorflow as tf\n",
    "import pandas as pd\n",
    "from sklearn.preprocessing import StandardScaler, PolynomialFeatures\n",
    "from sklearn.pipeline import Pipeline\n",
    "\n",
    "def prepare_data_for_tpu(df:pd.DataFrame, features_cols:list[str], target_col:str, batch_size:int=32, poly_degree:int=2, poly:bool=False, valid_split:bool=False,valid_split_size:float=0.2):\n",
    "\n",
    "    df = df.copy()\n",
    "    features = df[features_cols]\n",
    "    target = df.loc[:, target_col]\n",
    "\n",
    "    pipe = Pipeline([\n",
    "        ('scaler', StandardScaler()),\n",
    "        ('poly', PolynomialFeatures(degree=poly_degree, include_bias=False, interaction_only=True)) if poly else None\n",
    "    ])\n",
    "    pipe.steps = [step for step in pipe.steps if step is not None]\n",
    "\n",
    "    features_final = pipe.fit_transform(features)\n",
    "    features_final_df = pd.DataFrame(features_final, columns=[f'feature_{i}' for i in range(features_final.shape[1])])\n",
    "\n",
    "\n",
    "    features_tensor = tf.convert_to_tensor(features_final_df.values.astype('float32'), dtype=tf.float32)\n",
    "    target_tensor = tf.convert_to_tensor(target.values.astype('int64'), dtype=tf.int64)\n",
    "\n",
    "    dataset = tf.data.Dataset.from_tensor_slices((features_tensor, target_tensor))\n",
    "\n",
    "    dataset_size = len(features)\n",
    "    val_size = int(valid_split_size * dataset_size)\n",
    "    if valid_split and (valid_split_size > 0.0):\n",
    "        valid_dataset = dataset.take(val_size).batch(batch_size).prefetch(tf.data.experimental.AUTOTUNE)\n",
    "        train_dataset = dataset.skip(val_size).shuffle(buffer_size=dataset_size-val_size).batch(batch_size).prefetch(tf.data.experimental.AUTOTUNE)\n",
    "\n",
    "        result = (train_dataset, valid_dataset)\n",
    "    else:\n",
    "        dataset = dataset.shuffle(buffer_size=dataset_size).batch(batch_size).prefetch(tf.data.experimental.AUTOTUNE)\n",
    "\n",
    "        result = (dataset, )\n",
    "    return result\n",
    "\n",
    "print('preparing the datasets for tpu and splitting them into train and valid datasets: \\n')\n",
    "try:\n",
    "    train_dataset, valid_dataset = prepare_data_for_tpu(df_train, features_cols=features_cols, target_col=target_col, poly=True, poly_degree=5, valid_split=True, valid_split_size=0.2)\n",
    "except Exception as e:\n",
    "    print('Could not prepare the datasets.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "ec421917",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:06.840209Z",
     "iopub.status.busy": "2024-10-25T21:08:06.839872Z",
     "iopub.status.idle": "2024-10-25T21:08:06.845337Z",
     "shell.execute_reply": "2024-10-25T21:08:06.844482Z"
    },
    "id": "hTc4q5oS2pYM",
    "papermill": {
     "duration": 0.023225,
     "end_time": "2024-10-25T21:08:06.847286",
     "exception": false,
     "start_time": "2024-10-25T21:08:06.824061",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# import tensorflow as tf\n",
    "# import keras\n",
    "# from keras import activations, layers, initializers, regularizers, optimizers, losses, metrics\n",
    "\n",
    "# with strategy.scope():\n",
    "#     class ann_layer_gen:\n",
    "#         def __init__(self, input_shape, batch_norm:bool=False, drop_out:bool=False, regularize:bool=False,  initializers :bool=False,drop_out_rate:float=0.0) -> None:\n",
    "#             self.input_shape = input_shape\n",
    "#             self.batch_norm = batch_norm\n",
    "#             self.drop_out = drop_out\n",
    "#             self.regularize = regularize\n",
    "#             self.initializers = initializers\n",
    "#             self.drop_out_rate = drop_out_rate\n",
    "#             self.model = keras.Sequential()\n",
    "#             self.model.add(keras.Input(shape=(input_shape, )))\n",
    "\n",
    "#         def __call__(self,  out_act_fun:activations, out_unit:int, units:int=100, n_hidden_layers:int=5,  hidden_act_fun:activations=activations.relu) -> keras.Sequential :\n",
    "#             for n_layer in range(1, n_hidden_layers+1):\n",
    "#                 layer_params = {'units':units, 'activation':hidden_act_fun}\n",
    "\n",
    "#                 if self.regularize:\n",
    "#                     layer_params['kernel_regularizer'] = regularizers.L1()\n",
    "#                 if self.initializers:\n",
    "#                     layer_params['kernel_initializer'] = initializers.glorot_normal\n",
    "\n",
    "#                 self.model.add(layers.Dense(**layer_params))\n",
    "\n",
    "#                 if self.drop_out:\n",
    "#                     self.model.add(layers.Dropout(rate=self.drop_out_rate))\n",
    "\n",
    "#                 if self.batch_norm:\n",
    "#                     self.model.add(layers.BatchNormalization())\n",
    "\n",
    "#                 units = round(units / 2)\n",
    "#             self.model.add(layers.Dense(out_unit, activation=out_act_fun))\n",
    "#             return self.model\n",
    "\n",
    "#         def compile(model, loss:losses.Loss, metrics:list=['accuracy'], optimizer:optimizers.Optimizer=optimizers.Adam, valid_split:float=0.2, learning_rate:float=0.01 ) -> keras.Sequential:\n",
    "#             try:\n",
    "#                 model.compile(optimizer=optimizer(learning_rate=learning_rate), loss=loss, metrics=metrics)\n",
    "#             except Exception as e:\n",
    "#                 print('Could not compile the model with given params.')\n",
    "#             return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "0c231401",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:06.877979Z",
     "iopub.status.busy": "2024-10-25T21:08:06.877299Z",
     "iopub.status.idle": "2024-10-25T21:08:07.024381Z",
     "shell.execute_reply": "2024-10-25T21:08:07.023359Z"
    },
    "id": "GcvJ_1h72pYN",
    "outputId": "5c8b208c-fd5c-4d8d-905e-4c9eb3f1ff51",
    "papermill": {
     "duration": 0.164687,
     "end_time": "2024-10-25T21:08:07.026670",
     "exception": false,
     "start_time": "2024-10-25T21:08:06.861983",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "import keras\n",
    "from keras import activations, layers, initializers, regularizers, optimizers, losses\n",
    "import optuna\n",
    "from keras import backend as K\n",
    "\n",
    "input_shape = train_dataset.element_spec[0].shape[1]  # Assuming first element is the feature tensor\n",
    "\n",
    "# Objective function for Optuna\n",
    "def objective(trial: optuna.Trial):\n",
    "    # Define hyperparameters\n",
    "    epochs = trial.suggest_int('epochs', 10, 100, step=10)\n",
    "    units = trial.suggest_int('units', 100, 500, step=50)\n",
    "    n_hidden_layers = trial.suggest_int('n_hidden_layers', 3, 19, step=2)\n",
    "    batch_norm = trial.suggest_categorical('batch_norm', [True, False])\n",
    "    drop_out = trial.suggest_categorical('drop_out', [True, False])\n",
    "    regularize = trial.suggest_categorical('regularize', [True, False])\n",
    "    initializers = trial.suggest_categorical('initializers', [True, False])\n",
    "    drop_out_rate = trial.suggest_float('drop_out_rate', 0, 1)\n",
    "    learning_rate = trial.suggest_float('learning_rate', 1e-6, 1e-1, log=True)\n",
    "    optimizer_name = trial.suggest_categorical('optimizer', ['Adam', 'RMSprop', 'SGD', 'Nadam'])\n",
    "    \n",
    "    # Create optimizer object based on the selected name\n",
    "    if optimizer_name == 'Adam':\n",
    "        optimizer = optimizers.Adam(learning_rate=learning_rate)\n",
    "    elif optimizer_name == 'RMSprop':\n",
    "        optimizer = optimizers.RMSprop(learning_rate=learning_rate)\n",
    "    elif optimizer_name == 'SGD':\n",
    "        optimizer = optimizers.SGD(learning_rate=learning_rate)\n",
    "    elif optimizer_name == 'Nadam':\n",
    "        optimizer = optimizers.Nadam(learning_rate=learning_rate)\n",
    "\n",
    "\n",
    "    # Building the model within strategy scope\n",
    "    with strategy.scope():\n",
    "        # Model building function\n",
    "        def build_model(input_shape, units, n_hidden_layers, batch_norm, drop_out, regularize, initializers, drop_out_rate):\n",
    "            model = keras.Sequential()\n",
    "            model.add(keras.Input(shape=(input_shape,)))\n",
    "\n",
    "            for _ in range(n_hidden_layers):\n",
    "                layer_params = {'units': units, 'activation': activations.relu}\n",
    "\n",
    "                if regularize:\n",
    "                    layer_params['kernel_regularizer'] = regularizers.L1()\n",
    "                if initializers:\n",
    "                    layer_params['kernel_initializer'] = keras.initializers.glorot_normal()\n",
    "\n",
    "                model.add(layers.Dense(**layer_params))\n",
    "\n",
    "                if drop_out:\n",
    "                    model.add(layers.Dropout(rate=drop_out_rate))\n",
    "                if batch_norm:\n",
    "                    model.add(layers.BatchNormalization())\n",
    "                \n",
    "                units = max(2, round(units / 2))  # Gradual reduction in units\n",
    "\n",
    "            # Output layer\n",
    "            model.add(layers.Dense(1, activation=activations.sigmoid))\n",
    "            return model\n",
    "\n",
    "        # Model compilation function\n",
    "        def compile_model(model, optimizer):\n",
    "            model.compile(optimizer=optimizer, loss=losses.binary_crossentropy, metrics=['accuracy'])\n",
    "            return model\n",
    "\n",
    "        # Model training function\n",
    "        def train_model(model, train_dataset, valid_dataset, epochs):\n",
    "            history = model.fit(\n",
    "                train_dataset,\n",
    "                validation_data=valid_dataset,\n",
    "                batch_size=32,\n",
    "                epochs=epochs,\n",
    "                shuffle=True,\n",
    "                verbose=0\n",
    "            )\n",
    "            return history\n",
    "\n",
    "        # Build, compile, and train the model\n",
    "        model = build_model(input_shape, units, n_hidden_layers, batch_norm, drop_out, regularize, initializers, drop_out_rate)\n",
    "        model = compile_model(model, optimizer)\n",
    "        history = train_model(model, train_dataset, valid_dataset, epochs)\n",
    "\n",
    "    # Retrieve metrics\n",
    "    val_accuracy = history.history['val_accuracy'][-1]\n",
    "    train_accuracy = history.history['accuracy'][-1]\n",
    "    val_loss = history.history['val_loss'][-1]\n",
    "    train_loss = history.history['loss'][-1]\n",
    "\n",
    "    K.clear_session()\n",
    "    return train_loss, train_accuracy\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "ae231195",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:07.056987Z",
     "iopub.status.busy": "2024-10-25T21:08:07.056676Z",
     "iopub.status.idle": "2024-10-25T21:08:14.669341Z",
     "shell.execute_reply": "2024-10-25T21:08:14.668372Z"
    },
    "id": "EUJ9C6aY2pYN",
    "outputId": "beb5aee4-7818-45bc-80e4-cbebafadc0e7",
    "papermill": {
     "duration": 7.630209,
     "end_time": "2024-10-25T21:08:14.671582",
     "exception": false,
     "start_time": "2024-10-25T21:08:07.041373",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "removing the previous study db file if exist\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.10/pty.py:89: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.\n",
      "  pid, fd = os.forkpty()\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "creating and optimizing the study with no of trials = 100\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[I 2024-10-25 21:08:09,645] A new study created in RDB with name: loan_approval_ann_study\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "df27768319f6478fbd1410e7a32b95b2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "  0%|          | 0/100 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[W 2024-10-25 21:08:14,662] Trial 0 failed with parameters: {'epochs': 60, 'units': 350, 'n_hidden_layers': 15, 'batch_norm': True, 'drop_out': False, 'regularize': True, 'initializers': True, 'drop_out_rate': 0.6379349745223628, 'learning_rate': 3.077163606905604e-05, 'optimizer': 'RMSprop'} because of the following error: RuntimeError('in user code:\\n\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/trainer.py\", line 104, in one_step_on_data  **\\n        return self.train_step(data)\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/trainer.py\", line 69, in train_step\\n        self.optimizer.apply_gradients(zip(gradients, trainable_weights))\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/base_optimizer.py\", line 282, in apply_gradients\\n        self.apply(grads, trainable_variables)\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/base_optimizer.py\", line 321, in apply\\n        self.build(trainable_variables)\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/rmsprop.py\", line 100, in build\\n        self.add_variable_from_reference(var, \"velocity\")\\n    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/optimizer.py\", line 33, in add_variable_from_reference\\n        with self._distribution_strategy.extended.colocate_vars_with(\\n\\n    RuntimeError: Mixing different tf.distribute.Strategy objects: <tensorflow.python.distribute.mirrored_strategy.MirroredStrategy object at 0x79ad9879db70> is not <tensorflow.python.distribute.distribute_lib._DefaultDistributionStrategy object at 0x79ac458fb550>\\n').\n",
      "Traceback (most recent call last):\n",
      "  File \"/opt/conda/lib/python3.10/site-packages/optuna/study/_optimize.py\", line 197, in _run_trial\n",
      "    value_or_values = func(trial)\n",
      "  File \"/tmp/ipykernel_24/1124424829.py\", line 82, in objective\n",
      "    history = train_model(model, train_dataset, valid_dataset, epochs)\n",
      "  File \"/tmp/ipykernel_24/1124424829.py\", line 69, in train_model\n",
      "    history = model.fit(\n",
      "  File \"/opt/conda/lib/python3.10/site-packages/keras/src/utils/traceback_utils.py\", line 122, in error_handler\n",
      "    raise e.with_traceback(filtered_tb) from None\n",
      "  File \"/tmp/__autograph_generated_filen12psbjw.py\", line 14, in tf__wrapped_fn\n",
      "    retval_ = ag__.converted_call(ag__.ld(call_for_each_replica), (ag__.ld(strategy), ag__.ld(fn).python_function, ag__.ld(args), ag__.ld(kwargs)), None, fscope)\n",
      "RuntimeError: in user code:\n",
      "\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/trainer.py\", line 104, in one_step_on_data  **\n",
      "        return self.train_step(data)\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/trainer.py\", line 69, in train_step\n",
      "        self.optimizer.apply_gradients(zip(gradients, trainable_weights))\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/base_optimizer.py\", line 282, in apply_gradients\n",
      "        self.apply(grads, trainable_variables)\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/base_optimizer.py\", line 321, in apply\n",
      "        self.build(trainable_variables)\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/optimizers/rmsprop.py\", line 100, in build\n",
      "        self.add_variable_from_reference(var, \"velocity\")\n",
      "    File \"/opt/conda/lib/python3.10/site-packages/keras/src/backend/tensorflow/optimizer.py\", line 33, in add_variable_from_reference\n",
      "        with self._distribution_strategy.extended.colocate_vars_with(\n",
      "\n",
      "    RuntimeError: Mixing different tf.distribute.Strategy objects: <tensorflow.python.distribute.mirrored_strategy.MirroredStrategy object at 0x79ad9879db70> is not <tensorflow.python.distribute.distribute_lib._DefaultDistributionStrategy object at 0x79ac458fb550>\n",
      "\n",
      "[W 2024-10-25 21:08:14,665] Trial 0 failed with value None.\n",
      "could not create the study\n",
      "created the srudy with no of trials = 100\n"
     ]
    }
   ],
   "source": [
    "print('removing the previous study db file if exist')\n",
    "try:\n",
    "    !rm -rf loan_approval_ann_study.db\n",
    "except Exception as e:\n",
    "    print('could not remove the db file')\n",
    "n_trials=100\n",
    "print('creating and optimizing the study with no of trials = 100')\n",
    "try:\n",
    "    loan_approval_ann_study = optuna.create_study(\n",
    "    storage='sqlite:///loan_approval_ann_study.db',\n",
    "    study_name='loan_approval_ann_study',\n",
    "    directions=['minimize', 'minimize'],\n",
    "    load_if_exists=True\n",
    "    )\n",
    "\n",
    "    loan_approval_ann_study.optimize(objective,  n_trials=n_trials, show_progress_bar=True)\n",
    "    print('study completed')\n",
    "except Exception as e:\n",
    "    print(f'could not create the study')\n",
    "print(f'created the srudy with no of trials = {n_trials}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "85867b55",
   "metadata": {
    "papermill": {
     "duration": 0.014959,
     "end_time": "2024-10-25T21:08:14.701986",
     "exception": false,
     "start_time": "2024-10-25T21:08:14.687027",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "2e73d63a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:14.734691Z",
     "iopub.status.busy": "2024-10-25T21:08:14.733877Z",
     "iopub.status.idle": "2024-10-25T21:08:14.738863Z",
     "shell.execute_reply": "2024-10-25T21:08:14.738017Z"
    },
    "id": "iBXn-Au62pYN",
    "outputId": "cc1f0839-eeb5-466d-c2f7-2c60c8319fca",
    "papermill": {
     "duration": 0.023664,
     "end_time": "2024-10-25T21:08:14.740731",
     "exception": false,
     "start_time": "2024-10-25T21:08:14.717067",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# from sklearn.preprocessing import OrdinalEncoder, OneHotEncoder\n",
    "# from sklearn.compose import ColumnTransformer\n",
    "# from sklearn.pipeline import Pipeline\n",
    "\n",
    "\n",
    "# print('encoding the final test data set')\n",
    "# ord_enc_test = OrdinalEncoder()\n",
    "# one_hot_enc_test = OneHotEncoder(sparse_output=False)\n",
    "\n",
    "# test_cat_cols = test_df.select_dtypes('object').columns\n",
    "# ordinal_cols = ['loan_grade']\n",
    "# one_hot_cols = [col for col in test_cat_cols if col != 'loan_grade']\n",
    "# remaining_cols = [col for col in test_df.columns if col not in list(test_cat_cols)]\n",
    "\n",
    "# encoder_test = ColumnTransformer(\n",
    "#             transformers=[\n",
    "#                 ('ordinal_encoder', ord_enc_test, ordinal_cols),\n",
    "#                 ('one_hot_encoder', one_hot_enc_test, one_hot_cols),\n",
    "#                 ('passthrough', 'passthrough', remaining_cols )\n",
    "#             ]\n",
    "# )\n",
    "\n",
    "# encoded_data = encoder_test.fit_transform(test_df)\n",
    "# one_hot_enc_test.fit(test_df[one_hot_cols])\n",
    "# one_hot_encoded_cols = one_hot_enc_test.get_feature_names_out(one_hot_cols)\n",
    "# all_cols = ordinal_cols + list(one_hot_encoded_cols) + remaining_cols\n",
    "# test_df_encoded = pd.DataFrame(encoded_data, columns=all_cols)\n",
    "# test_df_encoded.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "dc550ec7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-10-25T21:08:14.772240Z",
     "iopub.status.busy": "2024-10-25T21:08:14.771961Z",
     "iopub.status.idle": "2024-10-25T21:08:14.776466Z",
     "shell.execute_reply": "2024-10-25T21:08:14.775624Z"
    },
    "id": "FklppLUM2pYO",
    "papermill": {
     "duration": 0.02228,
     "end_time": "2024-10-25T21:08:14.778265",
     "exception": false,
     "start_time": "2024-10-25T21:08:14.755985",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# import tensorflow as tf\n",
    "# import pandas as pd\n",
    "# from sklearn.preprocessing import StandardScaler, PolynomialFeatures\n",
    "# from sklearn.pipeline import Pipeline\n",
    "\n",
    "# def prepare_test_data_for_tpu(df: pd.DataFrame, features_cols: list[str], target_col: str, batch_size: int = 32, poly_degree: int = 2, poly: bool = False):\n",
    "\n",
    "#     df = df.copy()\n",
    "#     features = df[features_cols]\n",
    "#     target = df[target_col]\n",
    "\n",
    "#     # Define pipeline for scaling and optional polynomial features\n",
    "#     pipe = Pipeline([\n",
    "#         ('scaler', StandardScaler()),\n",
    "#         ('poly', PolynomialFeatures(degree=poly_degree, include_bias=False, interaction_only=True)) if poly else None\n",
    "#     ])\n",
    "#     pipe.steps = [step for step in pipe.steps if step is not None]\n",
    "\n",
    "#     # Transform features\n",
    "#     features_final = pipe.fit_transform(features)\n",
    "#     features_final_df = pd.DataFrame(features_final, columns=[f'feature_{i}' for i in range(features_final.shape[1])])\n",
    "\n",
    "#     # Create tf.data.Dataset without shuffling, batching only\n",
    "#     dataset = tf.data.Dataset.from_tensor_slices((dict(features_final_df), target))\n",
    "#     dataset = dataset.batch(batch_size).prefetch(tf.data.experimental.AUTOTUNE)\n",
    "\n",
    "#     return dataset\n"
   ]
  }
 ],
 "metadata": {
  "accelerator": "TPU",
  "colab": {
   "gpuType": "V28",
   "include_colab_link": true,
   "provenance": []
  },
  "kaggle": {
   "accelerator": "nvidiaTeslaT4",
   "dataSources": [
    {
     "databundleVersionId": 9709193,
     "sourceId": 84894,
     "sourceType": "competition"
    },
    {
     "datasetId": 5936521,
     "sourceId": 9706567,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 5948628,
     "sourceId": 9722405,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30787,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 55.881315,
   "end_time": "2024-10-25T21:08:17.826157",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-10-25T21:07:21.944842",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "0ac5ae90381d461581bebf77a681ec8e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "1700b92aad8149c293e1bbf94e0f8d5a": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     },
     "2dbccdf0c9184f2eb1afae897d331ee3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "34c21e44ff3d402591207abc1878cf0a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "8ffaa682dee74355b0e09985d7adff18": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_dc19654a982c40278d87996254829cde",
       "placeholder": "",
       "style": "IPY_MODEL_2dbccdf0c9184f2eb1afae897d331ee3",
       "value": "0%"
      }
     },
     "9b5bae8888fd4f479d32ccbc25dc6078": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "a0834cc7c8cd4af1b7ef166ecd77135c": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "c2e7ff369c434a169a0b10eaed752dd6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "ProgressView",
       "bar_style": "danger",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_a0834cc7c8cd4af1b7ef166ecd77135c",
       "max": 100.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_1700b92aad8149c293e1bbf94e0f8d5a",
       "value": 0.0
      }
     },
     "c954ee714d964c0cb2146a6928f17bb8": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_34c21e44ff3d402591207abc1878cf0a",
       "placeholder": "",
       "style": "IPY_MODEL_9b5bae8888fd4f479d32ccbc25dc6078",
       "value": "0/100[00:05&lt;?,?it/s]"
      }
     },
     "dc19654a982c40278d87996254829cde": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "df27768319f6478fbd1410e7a32b95b2": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_8ffaa682dee74355b0e09985d7adff18",
        "IPY_MODEL_c2e7ff369c434a169a0b10eaed752dd6",
        "IPY_MODEL_c954ee714d964c0cb2146a6928f17bb8"
       ],
       "layout": "IPY_MODEL_0ac5ae90381d461581bebf77a681ec8e"
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
